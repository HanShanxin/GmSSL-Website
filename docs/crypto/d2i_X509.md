# NAME

d2i\_ACCESS\_DESCRIPTION,
d2i\_ASIdOrRange,
d2i\_ASIdentifierChoice,
d2i\_ASIdentifiers,
d2i\_ASN1\_BIT\_STRING,
d2i\_ASN1\_BMPSTRING,
d2i\_ASN1\_ENUMERATED,
d2i\_ASN1\_GENERALIZEDTIME,
d2i\_ASN1\_GENERALSTRING,
d2i\_ASN1\_IA5STRING,
d2i\_ASN1\_INTEGER,
d2i\_ASN1\_NULL,
d2i\_ASN1\_OBJECT,
d2i\_ASN1\_OCTET\_STRING,
d2i\_ASN1\_PRINTABLE,
d2i\_ASN1\_PRINTABLESTRING,
d2i\_ASN1\_SEQUENCE\_ANY,
d2i\_ASN1\_SET\_ANY,
d2i\_ASN1\_T61STRING,
d2i\_ASN1\_TIME,
d2i\_ASN1\_TYPE,
d2i\_ASN1\_UINTEGER,
d2i\_ASN1\_UNIVERSALSTRING,
d2i\_ASN1\_UTCTIME,
d2i\_ASN1\_UTF8STRING,
d2i\_ASN1\_VISIBLESTRING,
d2i\_ASRange,
d2i\_AUTHORITY\_INFO\_ACCESS,
d2i\_AUTHORITY\_KEYID,
d2i\_BASIC\_CONSTRAINTS,
d2i\_CERTIFICATEPOLICIES,
d2i\_CMS\_ContentInfo,
d2i\_CMS\_ReceiptRequest,
d2i\_CMS\_bio,
d2i\_CRL\_DIST\_POINTS,
d2i\_DHxparams,
d2i\_DIRECTORYSTRING,
d2i\_DISPLAYTEXT,
d2i\_DIST\_POINT,
d2i\_DIST\_POINT\_NAME,
d2i\_DSAPrivateKey,
d2i\_DSAPrivateKey\_bio,
d2i\_DSAPrivateKey\_fp,
d2i\_DSAPublicKey,
d2i\_DSA\_PUBKEY\_bio,
d2i\_DSA\_PUBKEY\_fp,
d2i\_DSA\_SIG,
d2i\_DSAparams,
d2i\_ECPKParameters,
d2i\_ECParameters,
d2i\_ECPrivateKey,
d2i\_ECPrivateKey\_bio,
d2i\_ECPrivateKey\_fp,
d2i\_EC\_PUBKEY,
d2i\_EC\_PUBKEY\_bio,
d2i\_EC\_PUBKEY\_fp,
d2i\_EDIPARTYNAME,
d2i\_ESS\_CERT\_ID,
d2i\_ESS\_ISSUER\_SERIAL,
d2i\_ESS\_SIGNING\_CERT,
d2i\_EXTENDED\_KEY\_USAGE,
d2i\_GENERAL\_NAME,
d2i\_GENERAL\_NAMES,
d2i\_IPAddressChoice,
d2i\_IPAddressFamily,
d2i\_IPAddressOrRange,
d2i\_IPAddressRange,
d2i\_ISSUING\_DIST\_POINT,
d2i\_NETSCAPE\_CERT\_SEQUENCE,
d2i\_NETSCAPE\_SPKAC,
d2i\_NETSCAPE\_SPKI,
d2i\_NOTICEREF,
d2i\_OCSP\_BASICRESP,
d2i\_OCSP\_CERTID,
d2i\_OCSP\_CERTSTATUS,
d2i\_OCSP\_CRLID,
d2i\_OCSP\_ONEREQ,
d2i\_OCSP\_REQINFO,
d2i\_OCSP\_REQUEST,
d2i\_OCSP\_RESPBYTES,
d2i\_OCSP\_RESPDATA,
d2i\_OCSP\_RESPID,
d2i\_OCSP\_RESPONSE,
d2i\_OCSP\_REVOKEDINFO,
d2i\_OCSP\_SERVICELOC,
d2i\_OCSP\_SIGNATURE,
d2i\_OCSP\_SINGLERESP,
d2i\_OTHERNAME,
d2i\_PBE2PARAM,
d2i\_PBEPARAM,
d2i\_PBKDF2PARAM,
d2i\_PKCS12,
d2i\_PKCS12\_BAGS,
d2i\_PKCS12\_MAC\_DATA,
d2i\_PKCS12\_SAFEBAG,
d2i\_PKCS12\_bio,
d2i\_PKCS12\_fp,
d2i\_PKCS7,
d2i\_PKCS7\_DIGEST,
d2i\_PKCS7\_ENCRYPT,
d2i\_PKCS7\_ENC\_CONTENT,
d2i\_PKCS7\_ENVELOPE,
d2i\_PKCS7\_ISSUER\_AND\_SERIAL,
d2i\_PKCS7\_RECIP\_INFO,
d2i\_PKCS7\_SIGNED,
d2i\_PKCS7\_SIGNER\_INFO,
d2i\_PKCS7\_SIGN\_ENVELOPE,
d2i\_PKCS7\_bio,
d2i\_PKCS7\_fp,
d2i\_PKCS8\_PRIV\_KEY\_INFO,
d2i\_PKCS8\_PRIV\_KEY\_INFO\_bio,
d2i\_PKCS8\_PRIV\_KEY\_INFO\_fp,
d2i\_PKCS8\_bio,
d2i\_PKCS8\_fp,
d2i\_PKEY\_USAGE\_PERIOD,
d2i\_POLICYINFO,
d2i\_POLICYQUALINFO,
d2i\_PROXY\_CERT\_INFO\_EXTENSION,
d2i\_PROXY\_POLICY,
d2i\_PublicKey,
d2i\_RSAPrivateKey,
d2i\_RSAPrivateKey\_bio,
d2i\_RSAPrivateKey\_fp,
d2i\_RSAPublicKey,
d2i\_RSAPublicKey\_bio,
d2i\_RSAPublicKey\_fp,
d2i\_RSA\_OAEP\_PARAMS,
d2i\_RSA\_PSS\_PARAMS,
d2i\_RSA\_PUBKEY,
d2i\_RSA\_PUBKEY\_bio,
d2i\_RSA\_PUBKEY\_fp,
d2i\_SCT\_LIST,
d2i\_SXNET,
d2i\_SXNETID,
d2i\_TS\_ACCURACY,
d2i\_TS\_MSG\_IMPRINT,
d2i\_TS\_MSG\_IMPRINT\_bio,
d2i\_TS\_MSG\_IMPRINT\_fp,
d2i\_TS\_REQ,
d2i\_TS\_REQ\_bio,
d2i\_TS\_REQ\_fp,
d2i\_TS\_RESP,
d2i\_TS\_RESP\_bio,
d2i\_TS\_RESP\_fp,
d2i\_TS\_STATUS\_INFO,
d2i\_TS\_TST\_INFO,
d2i\_TS\_TST\_INFO\_bio,
d2i\_TS\_TST\_INFO\_fp,
d2i\_USERNOTICE,
d2i\_X509,
d2i\_X509\_ALGOR,
d2i\_X509\_ALGORS,
d2i\_X509\_ATTRIBUTE,
d2i\_X509\_CERT\_AUX,
d2i\_X509\_CINF,
d2i\_X509\_CRL,
d2i\_X509\_CRL\_INFO,
d2i\_X509\_CRL\_bio,
d2i\_X509\_CRL\_fp,
d2i\_X509\_EXTENSION,
d2i\_X509\_EXTENSIONS,
d2i\_X509\_NAME,
d2i\_X509\_NAME\_ENTRY,
d2i\_X509\_PUBKEY,
d2i\_X509\_REQ,
d2i\_X509\_REQ\_INFO,
d2i\_X509\_REQ\_bio,
d2i\_X509\_REQ\_fp,
d2i\_X509\_REVOKED,
d2i\_X509\_SIG,
d2i\_X509\_VAL,
i2d\_ACCESS\_DESCRIPTION,
i2d\_ASIdOrRange,
i2d\_ASIdentifierChoice,
i2d\_ASIdentifiers,
i2d\_ASN1\_BIT\_STRING,
i2d\_ASN1\_BMPSTRING,
i2d\_ASN1\_ENUMERATED,
i2d\_ASN1\_GENERALIZEDTIME,
i2d\_ASN1\_GENERALSTRING,
i2d\_ASN1\_IA5STRING,
i2d\_ASN1\_INTEGER,
i2d\_ASN1\_NULL,
i2d\_ASN1\_OBJECT,
i2d\_ASN1\_OCTET\_STRING,
i2d\_ASN1\_PRINTABLE,
i2d\_ASN1\_PRINTABLESTRING,
i2d\_ASN1\_SEQUENCE\_ANY,
i2d\_ASN1\_SET\_ANY,
i2d\_ASN1\_T61STRING,
i2d\_ASN1\_TIME,
i2d\_ASN1\_TYPE,
i2d\_ASN1\_UNIVERSALSTRING,
i2d\_ASN1\_UTCTIME,
i2d\_ASN1\_UTF8STRING,
i2d\_ASN1\_VISIBLESTRING,
i2d\_ASN1\_bio\_stream,
i2d\_ASRange,
i2d\_AUTHORITY\_INFO\_ACCESS,
i2d\_AUTHORITY\_KEYID,
i2d\_BASIC\_CONSTRAINTS,
i2d\_CERTIFICATEPOLICIES,
i2d\_CMS\_ContentInfo,
i2d\_CMS\_ReceiptRequest,
i2d\_CMS\_bio,
i2d\_CRL\_DIST\_POINTS,
i2d\_DHxparams,
i2d\_DIRECTORYSTRING,
i2d\_DISPLAYTEXT,
i2d\_DIST\_POINT,
i2d\_DIST\_POINT\_NAME,
i2d\_DSAPrivateKey,
i2d\_DSAPrivateKey\_bio,
i2d\_DSAPrivateKey\_fp,
i2d\_DSAPublicKey,
i2d\_DSA\_PUBKEY\_bio,
i2d\_DSA\_PUBKEY\_fp,
i2d\_DSA\_SIG,
i2d\_DSAparams,
i2d\_ECPKParameters,
i2d\_ECParameters,
i2d\_ECPrivateKey,
i2d\_ECPrivateKey\_bio,
i2d\_ECPrivateKey\_fp,
i2d\_EC\_PUBKEY,
i2d\_EC\_PUBKEY\_bio,
i2d\_EC\_PUBKEY\_fp,
i2d\_EDIPARTYNAME,
i2d\_ESS\_CERT\_ID,
i2d\_ESS\_ISSUER\_SERIAL,
i2d\_ESS\_SIGNING\_CERT,
i2d\_EXTENDED\_KEY\_USAGE,
i2d\_GENERAL\_NAME,
i2d\_GENERAL\_NAMES,
i2d\_IPAddressChoice,
i2d\_IPAddressFamily,
i2d\_IPAddressOrRange,
i2d\_IPAddressRange,
i2d\_ISSUING\_DIST\_POINT,
i2d\_NETSCAPE\_CERT\_SEQUENCE,
i2d\_NETSCAPE\_SPKAC,
i2d\_NETSCAPE\_SPKI,
i2d\_NOTICEREF,
i2d\_OCSP\_BASICRESP,
i2d\_OCSP\_CERTID,
i2d\_OCSP\_CERTSTATUS,
i2d\_OCSP\_CRLID,
i2d\_OCSP\_ONEREQ,
i2d\_OCSP\_REQINFO,
i2d\_OCSP\_REQUEST,
i2d\_OCSP\_RESPBYTES,
i2d\_OCSP\_RESPDATA,
i2d\_OCSP\_RESPID,
i2d\_OCSP\_RESPONSE,
i2d\_OCSP\_REVOKEDINFO,
i2d\_OCSP\_SERVICELOC,
i2d\_OCSP\_SIGNATURE,
i2d\_OCSP\_SINGLERESP,
i2d\_OTHERNAME,
i2d\_PBE2PARAM,
i2d\_PBEPARAM,
i2d\_PBKDF2PARAM,
i2d\_PKCS12,
i2d\_PKCS12\_BAGS,
i2d\_PKCS12\_MAC\_DATA,
i2d\_PKCS12\_SAFEBAG,
i2d\_PKCS12\_bio,
i2d\_PKCS12\_fp,
i2d\_PKCS7,
i2d\_PKCS7\_DIGEST,
i2d\_PKCS7\_ENCRYPT,
i2d\_PKCS7\_ENC\_CONTENT,
i2d\_PKCS7\_ENVELOPE,
i2d\_PKCS7\_ISSUER\_AND\_SERIAL,
i2d\_PKCS7\_NDEF,
i2d\_PKCS7\_RECIP\_INFO,
i2d\_PKCS7\_SIGNED,
i2d\_PKCS7\_SIGNER\_INFO,
i2d\_PKCS7\_SIGN\_ENVELOPE,
i2d\_PKCS7\_bio,
i2d\_PKCS7\_fp,
i2d\_PKCS8PrivateKeyInfo\_bio,
i2d\_PKCS8PrivateKeyInfo\_fp,
i2d\_PKCS8\_PRIV\_KEY\_INFO,
i2d\_PKCS8\_PRIV\_KEY\_INFO\_bio,
i2d\_PKCS8\_PRIV\_KEY\_INFO\_fp,
i2d\_PKCS8\_bio,
i2d\_PKCS8\_fp,
i2d\_PKEY\_USAGE\_PERIOD,
i2d\_POLICYINFO,
i2d\_POLICYQUALINFO,
i2d\_PROXY\_CERT\_INFO\_EXTENSION,
i2d\_PROXY\_POLICY,
i2d\_PublicKey,
i2d\_RSAPrivateKey,
i2d\_RSAPrivateKey\_bio,
i2d\_RSAPrivateKey\_fp,
i2d\_RSAPublicKey,
i2d\_RSAPublicKey\_bio,
i2d\_RSAPublicKey\_fp,
i2d\_RSA\_OAEP\_PARAMS,
i2d\_RSA\_PSS\_PARAMS,
i2d\_RSA\_PUBKEY,
i2d\_RSA\_PUBKEY\_bio,
i2d\_RSA\_PUBKEY\_fp,
i2d\_SCT\_LIST,
i2d\_SXNET,
i2d\_SXNETID,
i2d\_TS\_ACCURACY,
i2d\_TS\_MSG\_IMPRINT,
i2d\_TS\_MSG\_IMPRINT\_bio,
i2d\_TS\_MSG\_IMPRINT\_fp,
i2d\_TS\_REQ,
i2d\_TS\_REQ\_bio,
i2d\_TS\_REQ\_fp,
i2d\_TS\_RESP,
i2d\_TS\_RESP\_bio,
i2d\_TS\_RESP\_fp,
i2d\_TS\_STATUS\_INFO,
i2d\_TS\_TST\_INFO,
i2d\_TS\_TST\_INFO\_bio,
i2d\_TS\_TST\_INFO\_fp,
i2d\_USERNOTICE,
i2d\_X509,
i2d\_X509\_ALGOR,
i2d\_X509\_ALGORS,
i2d\_X509\_ATTRIBUTE,
i2d\_X509\_CERT\_AUX,
i2d\_X509\_CINF,
i2d\_X509\_CRL,
i2d\_X509\_CRL\_INFO,
i2d\_X509\_CRL\_bio,
i2d\_X509\_CRL\_fp,
i2d\_X509\_EXTENSION,
i2d\_X509\_EXTENSIONS,
i2d\_X509\_NAME,
i2d\_X509\_NAME\_ENTRY,
i2d\_X509\_PUBKEY,
i2d\_X509\_REQ,
i2d\_X509\_REQ\_INFO,
i2d\_X509\_REQ\_bio,
i2d\_X509\_REQ\_fp,
i2d\_X509\_REVOKED,
i2d\_X509\_SIG,
i2d\_X509\_VAL,
\- convert objects from/to ASN.1/DER representation

# SYNOPSIS

    TYPE *d2i_TYPE(TYPE **a, unsigned char **pp, long length);
    TYPE *d2i_TYPE_bio(BIO *bp, TYPE **a);
    TYPE *d2i_TYPE_fp(FILE *fp, TYPE **a);

    int i2d_TYPE(TYPE *a, unsigned char **pp);
    int i2d_TYPE_fp(FILE *fp, TYPE *a);
    int i2d_TYPE_bio(BIO *bp, TYPE *a);

# DESCRIPTION

In the description here, _TYPE_ is used a placeholder
for any of the OpenSSL datatypes, such as _X509\_CRL_.

These functions convert OpenSSL objects to and from their ASN.1/DER
encoding.  Unlike the C structures which can have pointers to sub-objects
within, the DER is a serialized encoding, suitable for sending over the
network, writing to a file, and so on.

d2i\_TYPE() attempts to decode **len** bytes at **\*in**. If successful a
pointer to the **TYPE** structure is returned and **\*in** is incremented to
the byte following the parsed data.  If **a** is not **NULL** then a pointer
to the returned structure is also written to **\*a**.  If an error occurred
then **NULL** is returned.

On a successful return, if **\*a** is not **NULL** then it is assumed that **\*a**
contains a valid **TYPE** structure and an attempt is made to reuse it. This
"reuse" capability is present for historical compatibility but its use is
**strongly discouraged** (see BUGS below, and the discussion in the RETURN
VALUES section).

d2i\_TYPE\_bio() is similar to d2i\_TYPE() except it attempts
to parse data from BIO **bp**.

d2i\_TYPE\_fp() is similar to d2i\_TYPE() except it attempts
to parse data from FILE pointer **fp**.

i2d\_TYPE() encodes the structure pointed to by **a** into DER format.
If **out** is not **NULL**, it writes the DER encoded data to the buffer
at **\*out**, and increments it to point after the data just written.
If the return value is negative an error occurred, otherwise it
returns the length of the encoded data.

If **\*out** is **NULL** memory will be allocated for a buffer and the encoded
data written to it. In this case **\*out** is not incremented and it points
to the start of the data just written.

i2d\_TYPE\_bio() is similar to i2d\_TYPE() except it writes
the encoding of the structure **a** to BIO **bp** and it
returns 1 for success and 0 for failure.

i2d\_TYPE\_fp() is similar to i2d\_TYPE() except it writes
the encoding of the structure **a** to BIO **bp** and it
returns 1 for success and 0 for failure.

These routines do not encrypt private keys and therefore offer no
security; use [PEM\_write\_PrivateKey(3)](http://man.he.net/man3/PEM_write_PrivateKey) or similar for writing to files.

# NOTES

The letters **i** and **d** in **i2d\_TYPE** stand for
"internal" (that is, an internal C structure) and "DER" respectively.
So **i2d\_TYPE** converts from internal to DER.

The functions can also understand **BER** forms.

The actual TYPE structure passed to i2d\_TYPE() must be a valid
populated **TYPE** structure -- it **cannot** simply be fed with an
empty structure such as that returned by TYPE\_new().

The encoded data is in binary form and may contain embedded zeroes.
Therefore any FILE pointers or BIOs should be opened in binary mode.
Functions such as strlen() will **not** return the correct length
of the encoded structure.

The ways that **\*in** and **\*out** are incremented after the operation
can trap the unwary. See the **WARNINGS** section for some common
errors.
The reason for this-auto increment behaviour is to reflect a typical
usage of ASN1 functions: after one structure is encoded or decoded
another will be processed after it.

The following points about the data types might be useful:

- **ASN1\_OBJECT**

    Represents an ASN1 OBJECT IDENTIFIER.

- **DHparams**

    Represents a PKCS#3 DH parameters structure.

- **DHparamx**

    Represents a ANSI X9.42 DH parameters structure.

- **DSA\_PUBKEY**

    Represents a DSA public key using a **SubjectPublicKeyInfo** structure.

- **DSAPublicKey, DSAPrivateKey**

    Use a non-standard OpenSSL format and should be avoided; use **DSA\_PUBKEY**,
    **PEM\_write\_PrivateKey(3)**, or similar instead.

- **RSAPublicKey**

    Represents a PKCS#1 RSA public key structure.

- **X509\_ALGOR**

    Represents an **AlogrithmIdentifier** structure as used in IETF RFC 6960 and
    elsewhere.

- **X509\_Name**

    Represents a **Name** type as used for subject and issuer names in
    IETF RFC 6960 and elsewhere.

- **X509\_REQ**

    Represents a PKCS#10 certificate request.

- **X509\_SIG**

    Represents the **DigestInfo** structure defined in PKCS#1 and PKCS#7.

# EXAMPLES

Allocate and encode the DER encoding of an X509 structure:

    int len;
    unsigned char *buf;

    buf = NULL;
    len = i2d_X509(x, &buf);
    if (len < 0)
        /* error */

Attempt to decode a buffer:

    X509 *x;
    unsigned char *buf, *p;
    int len;

    /* Set up buf and len to point to the input buffer. */
    p = buf;
    x = d2i_X509(NULL, &p, len);
    if (x == NULL)
        /* error */

Alternative technique:

    X509 *x;
    unsigned char *buf, *p;
    int len;

    /* Set up buf and len to point to the input buffer. */
    p = buf;
    x = NULL;

    if (d2i_X509(&x, &p, len) == NULL)
        /* error */

# WARNINGS

Using a temporary variable is mandatory. A common
mistake is to attempt to use a buffer directly as follows:

    int len;
    unsigned char *buf;

    len = i2d_X509(x, NULL);
    buf = OPENSSL_malloc(len);
    ...
    i2d_X509(x, &buf);
    ...
    OPENSSL_free(buf);

This code will result in **buf** apparently containing garbage because
it was incremented after the call to point after the data just written.
Also **buf** will no longer contain the pointer allocated by OPENSSL\_malloc()
and the subsequent call to OPENSSL\_free() is likely to crash.

Another trap to avoid is misuse of the **a** argument to d2i\_TYPE():

    X509 *x;

    if (d2i_X509(&x, &p, len) == NULL)
        /* error */

This will probably crash somewhere in d2i\_X509(). The reason for this
is that the variable **x** is uninitialized and an attempt will be made to
interpret its (invalid) value as an **X509** structure, typically causing
a segmentation violation. If **x** is set to NULL first then this will not
happen.

# BUGS

In some versions of OpenSSL the "reuse" behaviour of d2i\_TYPE() when
**\*px** is valid is broken and some parts of the reused structure may
persist if they are not present in the new one. As a result the use
of this "reuse" behaviour is strongly discouraged.

i2d\_TYPE() will not return an error in many versions of OpenSSL,
if mandatory fields are not initialized due to a programming error
then the encoded structure may contain invalid data or omit the
fields entirely and will not be parsed by d2i\_TYPE(). This may be
fixed in future so code should not assume that i2d\_TYPE() will
always succeed.

Any function which encodes a structure (i2d\_TYPE(),
i2d\_TYPE() or i2d\_TYPE()) may return a stale encoding if the
structure has been modified after deserialization or previous
serialization. This is because some objects cache the encoding for
efficiency reasons.

# RETURN VALUES

d2i\_TYPE(), d2i\_TYPE\_bio() and d2i\_TYPE\_fp() return a valid **TYPE** structure
or **NULL** if an error occurs.  If the "reuse" capability has been used with
a valid structure being passed in via **a**, then the object is not freed in
the event of error but may be in a potentially invalid or inconsistent state.

i2d\_TYPE() returns the number of bytes successfully encoded or a negative
value if an error occurs.

i2d\_TYPE\_bio() and i2d\_TYPE\_fp() return 1 for success and 0 if an error
occurs.

# COPYRIGHT

Copyright 1998-2016 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the OpenSSL license (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
[https://www.openssl.org/source/license.html](https://www.openssl.org/source/license.html).
